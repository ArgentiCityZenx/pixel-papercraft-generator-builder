// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Path = require("path");
var $$Promise = require("@ryyppy/rescript-promise/src/Promise.bs.js");
var Imageinfo = require("imageinfo");
var MergeImg = require("merge-img");
var Caml_array = require("rescript/lib/js/caml_array.js");
var Child_process = require("child_process");

var $$Node = {};

var Stats = {};

var Fs$1 = {
  Stats: Stats
};

var Path$1 = {};

var ImageInfo = {};

var MergeImg$1 = {};

var ChildProcess = {};

function toImageWithInfo(path) {
  var isPNG = path.endsWith(".png");
  if (!isPNG) {
    return ;
  }
  var file = Fs.readFileSync(path);
  var info = Imageinfo(file);
  if (info.format === "PNG" && info.width === 16 && info.height % 16 === 0) {
    return {
            path: path,
            info: info
          };
  }
  
}

function toValidImage(acc, image) {
  if (image !== undefined) {
    return acc.concat([image]);
  } else {
    return acc;
  }
}

function isDirectory(path) {
  return Fs.statSync(path).isDirectory();
}

var texturesOriginalDir = Path.resolve(__dirname, "./textures-original");

var texturesDir = Path.resolve(__dirname, "./textures");

var dataFile = Path.resolve(__dirname, texturesDir + "/MinecraftBlock_TextureData.res");

var dirPaths = Fs.readdirSync(texturesOriginalDir).map(function (dirName) {
        return [
                dirName,
                texturesOriginalDir + "/" + dirName
              ];
      }).filter(function (param) {
      return Fs.statSync(param[1]).isDirectory();
    });

function makeVersions(param) {
  return dirPaths.map(function (param) {
              var dirPath = param[1];
              var fileNames = Fs.readdirSync(dirPath);
              var textures = fileNames.map(function (fileName) {
                          return dirPath + "/" + fileName;
                        }).map(toImageWithInfo).reduce(toValidImage, []).reduce((function (acc, image) {
                      var result = Path.parse(image.path);
                      var textureCount = acc.length;
                      var lastTexture = textureCount > 0 ? Caml_array.get(acc, textureCount - 1 | 0) : undefined;
                      var index = lastTexture !== undefined ? lastTexture.index + (lastTexture.frames << 4) | 0 : 0;
                      var texture_id = result.name;
                      var texture_filePath = dirPath + "/" + result.base;
                      var texture_frames = image.info.height / 16 | 0;
                      var texture = {
                        id: texture_id,
                        filePath: texture_filePath,
                        frames: texture_frames,
                        index: index
                      };
                      return acc.concat([texture]);
                    }), []);
              return {
                      id: param[0],
                      textures: textures
                    };
            });
}

function makeMergedTextureImages(versions) {
  return Promise.all(versions.map(function (param) {
                    var outPath = texturesDir + "/" + param.id + ".png";
                    var filePaths = param.textures.map(function (param) {
                          return param.filePath;
                        });
                    return MergeImg(filePaths, {
                                  direction: "vertical"
                                }).then(function (result) {
                                return new Promise((function (resolve, reject) {
                                              result.write(outPath, (function (error) {
                                                      if (error == null) {
                                                        return resolve(undefined);
                                                      } else {
                                                        return reject(error);
                                                      }
                                                    }));
                                              
                                            }));
                              });
                  })).then(function (param) {
              
            });
}

function makeDataFile(versions) {
  var versionsData = versions.map(function (param) {
        var textures = param.textures.map(function (param) {
              return {
                      id: param.id,
                      frames: param.frames,
                      index: param.index
                    };
            });
        return {
                id: param.id,
                textures: textures
              };
      });
  var texturesData = versionsData.map(function (versionData) {
            var standardHeight = versionData.textures.reduce((function (acc, texture) {
                    return acc + (texture.frames << 4) | 0;
                  }), 0);
            return {
                    id: versionData.id,
                    url: versionData.id + ".png",
                    standardWidth: 16,
                    standardHeight: standardHeight
                  };
          }).map(function (textureData) {
          return "\n    {\n      id: \"" + textureData.id + "\",\n      url: Generator.requireImage(\"./" + textureData.url + "\").default.src,\n      standardWidth: " + textureData.standardWidth.toString() + ",\n      standardHeight: " + textureData.standardHeight.toString() + ",\n    }\n    ";
        }).join(",");
  var texturesCode = "\n    let textures: array<Generator.textureDef> = [\n      " + texturesData + "\n    ]\n  ";
  var code = "\n    // This is a generated file\n\n    " + texturesCode + "\n\n    let versions = " + JSON.stringify(versionsData) + "\n  ";
  Fs.writeFileSync(dataFile, code);
  return new Promise((function (resolve, reject) {
                Child_process.exec("npx rescript format " + dataFile, (function (exn, stdout, stderr) {
                        if (exn == null) {
                          if (!(stdout == null)) {
                            console.log(stdout);
                          }
                          if (!(stderr == null)) {
                            console.log(stderr);
                          }
                          return resolve(undefined);
                        } else {
                          return reject(exn);
                        }
                      }));
                return resolve(undefined);
              }));
}

var versions = makeVersions(undefined);

$$Promise.$$catch(makeMergedTextureImages(versions).then(function (param) {
          return makeDataFile(versions);
        }), (function (exn) {
        console.log(exn);
        return Promise.resolve(undefined);
      }));

exports.$$Node = $$Node;
exports.Fs = Fs$1;
exports.Path = Path$1;
exports.ImageInfo = ImageInfo;
exports.MergeImg = MergeImg$1;
exports.ChildProcess = ChildProcess;
exports.toImageWithInfo = toImageWithInfo;
exports.toValidImage = toValidImage;
exports.isDirectory = isDirectory;
exports.texturesOriginalDir = texturesOriginalDir;
exports.texturesDir = texturesDir;
exports.dataFile = dataFile;
exports.dirPaths = dirPaths;
exports.makeVersions = makeVersions;
exports.makeMergedTextureImages = makeMergedTextureImages;
exports.makeDataFile = makeDataFile;
exports.versions = versions;
/* texturesOriginalDir Not a pure module */
